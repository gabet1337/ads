\documentclass[a4paper,oneside,article,11pt]{memoir}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm}

% This font looks so good.
\usepackage[sc]{mathpazo}

% Typesetting pseudo-code
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{multirow}
% Code comments like [CLRS]
\renewcommand{\algorithmiccomment}[1]{\makebox[5cm][l]{$\triangleright$ \textit{#1}}}
\usepackage{framed,graphicx,xcolor}
\usepackage[font={small,it}]{caption}
\usepackage{listings}
\usepackage{units}

% Relative references
\usepackage{varioref}

\usepackage{hyperref}

\bibliographystyle{plain}

\title{Advanced Data Structures \\ Project 3 - Theory project 5}
\author{Peter Gabrielsen 20114179 \\
Christoffer Hansen 20114637}
\newcounter{qcounter}
\begin{document}

\begin{titlingpage}
\clearpage

\maketitle
\thispagestyle{empty}

\begin{abstract}

\end{abstract}
\end{titlingpage}

\pagebreak

\tableofcontents

\pagebreak

\chapter{Introduction}
Introduction to the four exercises.

\chapter{Range minimum queries in two dimensions}
\label{chp:rmq2d}
\subsection{Problem description}
\textit{Let $A$ be a two dimensional array of size $n \times m$. Describe how to preprocess $A$ into a data structure that given a rectangular query range given by $(i_1,i_2,j_1,j_2)$ reports the minimum element in $A\left[ i1\dots i2\right]\left[j1\dots j2\right]$. State the space, preprocessing time, and query time of your data structure.}

\textit{Optional: What is the best space bound you can achieve with $\mathcal{O}(1)$ query time? What is the best query time you can achieve with $\mathcal{O}(nm)$ space?}

\subsection{Solution}
Magic!

\chapter{Nearest common ancestors under leaf insertions and deletions}
\label{chp:LCA}
\subsection{Problem description}
\textit{Describe a data structure to maintain a tree $T$ under the insertion and deletion of leafs (to insert a new leaf we are given a pointer to the parent node), while supporting nearest common ancestor queries of two arbitrary nodes in $T$. State the update and query time of your data structure.}

\textit{What are the best update and query bounds you can achieve?}

\subsection{Solution}
Might not be magic!

\chapter{In-place merging}
\label{chp:inplace}
\subsection{Problem description}
\textit{Describe an algorithm that given an array containing $n+m$ elements $x_1x_2\dots x_ny_1y_2\dots y_m$, where $x_1\leq x_2\leq \dots \leq x_n$ and $y_1\leq y_2\leq \dots \leq y_m$, inplace merges the two sorted sequences. State the running time of your algorithm.}

\textit{What is the best running time you can achieve?}

\subsection{Solution}
Not magic but encoding!

\chapter{Prefix counting}
\label{chp:prefix}
\subsection{Problem description}
\textit{Let $A$ be an array of size $n$, where each $A\left[i\right]$ is either $0$ or $1$. Describe a data structure that supports updating an entry of $A$ to either $0$ or $1$, and the query $sum_2\left(i\right)$ that returns $\left(A\left[1\right]+A\left[2\right]+\dots+A\left[i\right]\right) \mod 2$, i.e. decides if the sum of the first $i$ entries of $A$ is odd or even.}

\textit{ is the best query time and update time you can achieve? A lower bound of $\Omega(\log n/\log\log n)$ is known for the operations on the RAM.}

\textit{Optional: Generalize the construction to return the sum $A[1]+A[2]+\dots+A[i]$, i.e. the number of entries equal one among the first $i$ entries.}

\subsection{Solution}
Build tree of height log n / loglog n and solve problem in constant time per node up to root.

\bibliography{references}

\end{document}


